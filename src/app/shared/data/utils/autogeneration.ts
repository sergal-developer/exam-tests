import { QuestionEntity, TypeOperation } from "../entities/matters.entity";


declare let rando: any;

export class AutogenerateFunctions {
    // esta vaiable requiere que sea llenada desde un servicio this._quizService.getWords
    wordsCollection: any = [];

    constructor() {}

    autogenerateData(type: TypeOperation, minimun: any, maximun: any, quantity: any) {
        let dataGenerated = [];
        if ( minimun && maximun && quantity ) {
            const _minimun = parseInt(minimun, 10);
            const _maximun = parseInt(maximun, 10);
            const _quantity = parseInt(quantity, 10);

            const operations = this._generateTermByType(_minimun, _maximun, type, _quantity);

            for (let i = 0; i < quantity; i++) {
                // const element = new QuestionEntity(i, this.newQuestion.type, operations[i]);
                const element: any = new QuestionEntity(i, type, '');
                // evaluar si las operaciones son aritmeticas
                const aritmeticOperations = [TypeOperation.addition, TypeOperation.substract, TypeOperation.multiplication, TypeOperation.division];
                if ( aritmeticOperations.includes(type) ) {
                    element.term = operations[i];
                    // element.result = eval(element.term);
                }
    
                // evaluar si son secuencias logica en secuencia
                if ( type === TypeOperation.logicSequence ) {
                    element.term = null;
                    element.listOptions = operations[i];
                }
    
                // evaluar si son problemas logica
                if ( type === TypeOperation.logicOperators ) {
                    element.term = null;
                    element.listOptions = operations[i];
                }
    
                // evaluar si son problemas palabras
                if ( type === TypeOperation.word ) {
                    element.term = operations[i];
                }
    
                // evaluar si son problemas horas
                if ( type === TypeOperation.hour ) {
                    element.term = operations[i];
                }
    
                // evaluar si son problemas rangos
                if ( type === TypeOperation.range ) {
                    element.term = operations[i];
                }
    
                dataGenerated.push(element);
            }
    
            // Add into items questions
            if ( dataGenerated.length ) {
                dataGenerated.forEach((question, index) => {
                    question.id = index;
                });
            }
        }

        return dataGenerated;
    }

    private _generateTermByType(minimun: number, maximun: number, type: TypeOperation, quantity: number) {
        let results = [];

        // evaluar si las operaciones son aritmeticas
        const aritmeticOperations = [TypeOperation.addition, TypeOperation.substract, TypeOperation.multiplication, TypeOperation.division];
        if ( aritmeticOperations.includes(type) ) {
            results = this._generateArithmeticOperations(minimun, maximun, type, quantity);
        }

        // evaluar si son secuencias logica en secuencia
        if ( type === TypeOperation.logicSequence ) {
            results = this._generateLogicSequenceOperations(maximun, quantity);
        }

        // evaluar si son problemas logica
        if ( type === TypeOperation.logicOperators ) {
            results = this._generateLogicOperations(maximun, quantity);
        }

        // evaluar si son problemas palabras
        if ( type === TypeOperation.word ) {
            results = this._generateWordOperations(minimun, maximun, quantity);
        }

        // evaluar si son problemas horas
        if ( type === TypeOperation.hour ) {
            results = this._generateHoursOperations(quantity);
        }

        // evaluar si son problemas rangos
        if ( type === TypeOperation.range ) {
            results = this._generateRangeOperations(minimun, maximun, quantity);
        }

        return results;
    }

    private _generateArithmeticOperations(minimun: number, maximun: number, type: TypeOperation, quantity: number) {
        const results = [];
        let operator = null;
        switch (type) {
            case TypeOperation.addition:
                operator = '+';
                break;
            case TypeOperation.substract:
                operator = '-';
                break;
            case TypeOperation.multiplication:
                operator = '*';
                break;
            case TypeOperation.division:
                operator = '/';
                break;
            default:
                break;
        }

        for (let i = 0; i < quantity; i++) {
          const firstOperator = rando(minimun, maximun);
          const secondOperator = rando(minimun, maximun);
          
          results.push(`${firstOperator} ${operator} ${secondOperator}`);
        }

        return results;
    }

    private _generateRangeOperations(minimun: number, maximun: number, quantity: number) {
        const results = [];
        for (let i = 0; i < quantity; i++) {
          const steps = rando(minimun, maximun);
          
          results.push(`${ steps } rangeOf ${ maximun }`);
        }

        return results;
    }

    private _generateHoursOperations(quantity: number) {
        const results = [];
        const hours = [];
        const minutes = [];
        for (let h = 1; h < 12; h++) {
            const value = h < 10 ? `0${ h }` : `${ h }`;
            hours.push(value);
        }

        for (let m = 1; m < 60; m++) {
            const value = m < 10 ? `0${ m }` : `${ m }`;
            minutes.push(value);
        }

        for (let i = 0; i < quantity; i++) {
          const firstOperator = rando(hours);
          const secondOperator = rando(minutes);
          
          results.push(`${firstOperator.value} : ${secondOperator.value}`);
        }

        return results;
    }

    private _generateWordOperations(minimun: number, maximun: number, quantity: number) {
        const results: any = [];
        
        let words = this.wordsCollection.filter((x: any) => x.length <= maximun && x.length >= minimun);

        for (let i = 0; i < quantity; i++) {
          const word = rando(words);
          results.push(words[word.index]);
        }

        return results;
    }

    private _generateLogicSequenceOperations(maximun: number, quantity: number) {
        const results = [];
        const arrayModels = [
            {id: 1, name: 'Verde', image: './assets/svg/coin-green.svg' },
            {id: 2, name: 'Rojo', image: './assets/svg/coin-red.svg' },
            {id: 3, name: 'Amarillo', image: './assets/svg/coin-yellow.svg' },
            {id: 4, name: 'Gris', image: './assets/svg/coin-gray.svg' },
            {id: 5, name: 'Azul', image: './assets/svg/coin-blue.svg' },
        ];

        // generar patron
        maximun = maximun > arrayModels.length ? arrayModels.length : maximun;

        for (let i = 0; i < quantity; i++) {
            const pattern = [];
            for (let x = 0; x < maximun; x++) {
                const item = rando(arrayModels);
                pattern.push(arrayModels[item.index]);
            }
            pattern.push(pattern[pattern.length - 1]);

            results.push(pattern);
        }

        return results;
    }

    private _generateLogicOperations(maximun: number, quantity: number) {
        const results = [];
        const arrayModels = [
            {id: 1, name: 'Verde', image: './assets/svg/coin-green.svg' },
            {id: 2, name: 'Rojo', image: './assets/svg/coin-red.svg' },
            {id: 3, name: 'Amarillo', image: './assets/svg/coin-yellow.svg' },
            {id: 4, name: 'Gris', image: './assets/svg/coin-gray.svg' },
            {id: 5, name: 'Azul', image: './assets/svg/coin-blue.svg' },
        ];

        // generar patron
        maximun = maximun > arrayModels.length ? arrayModels.length : maximun;

        for (let i = 0; i < quantity; i++) {
            const pattern = [];
            for (let x = 0; x < maximun; x++) {
                const item = rando(arrayModels);
                pattern.push(arrayModels[item.index]);
            }
            pattern.push(pattern[pattern.length - 1]);

            results.push(pattern);
        }

        return results;
    }
}
